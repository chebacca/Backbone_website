var g=Object.defineProperty;var A=(a,t,l)=>t in a?g(a,t,{enumerable:!0,configurable:!0,writable:!0,value:l}):a[t]=l;var c=(a,t,l)=>A(a,typeof t!="symbol"?t+"":t,l);import{A as m}from"./DashboardCloudProjectsBridge-DJp-Ry15.js";import"./index-BasEdKm1.js";import"./mui-CCWxH8Vb.js";import"./vendor-CjD1bmmO.js";import"./stripe-vGaGA8Al.js";import"./index.esm-DdZh2hq1.js";import"./index.esm-Dkmm1Qng.js";import"./firebase-Skuf3wCp.js";import"./index.esm-e-DuI42t.js";import"./CloudProjectIntegration-D0_TS-hV.js";import"./UnifiedProjectCreationDialog-EC2tSjvp.js";import"./UnifiedDataService-DPkky4LM.js";import"./FirestoreCollectionManager-CAtMF_6_.js";const n=class n{constructor(){c(this,"dynamicDiscovery");c(this,"cachedCollections",null);c(this,"lastCacheUpdate",0);c(this,"CACHE_DURATION",5*60*1e3);this.dynamicDiscovery=new DynamicCollectionDiscovery}static getInstance(){return n.instance||(n.instance=new n),n.instance}async getAllAvailableCollections(){const t=Date.now();if(this.cachedCollections&&t-this.lastCacheUpdate<this.CACHE_DURATION)return this.cachedCollections;try{const l=await this.dynamicDiscovery.discoverCollections();if(l.success&&l.collections.length>0)return this.cachedCollections=l.collections,this.lastCacheUpdate=t,console.log("ðŸ” [DatasetCollectionValidator] Using dynamic collections:",this.cachedCollections.length),this.cachedCollections}catch(l){console.warn("âš ï¸ [DatasetCollectionValidator] Dynamic discovery failed, using static collections:",l)}return this.cachedCollections=m,this.lastCacheUpdate=t,console.log("ðŸ” [DatasetCollectionValidator] Using static collections:",this.cachedCollections.length),this.cachedCollections}async validateDatasetCollections(t,l={}){const i=await this.getAllAvailableCollections(),e=i.filter(d=>!t.includes(d)),o=t.filter(d=>!i.includes(d)),h=e.length===0&&o.length===0,r=[];return e.length>0&&r.push(`Add ${e.length} missing collections: ${e.slice(0,5).join(", ")}${e.length>5?"...":""}`),o.length>0&&r.push(`Remove ${o.length} invalid collections: ${o.slice(0,5).join(", ")}${o.length>5?"...":""}`),t.length<i.length*.8&&r.push('Consider using "Select All" to ensure complete data access'),{isValid:h,missingCollections:e,extraCollections:o,totalCollections:t.length,expectedCollections:i.length,recommendations:r}}async syncDatasetCollections(t,l={}){const s=await this.getAllAvailableCollections();let i=[...t];if(l.addMissingCollections!==!1){const e=s.filter(o=>!t.includes(o));i=[...i,...e],e.length>0&&console.log("âœ… [DatasetCollectionValidator] Added missing collections:",e.length)}if(l.removeExtraCollections){const e=i.filter(h=>s.includes(h)),o=i.length-e.length;i=e,o>0&&console.log("âœ… [DatasetCollectionValidator] Removed invalid collections:",o)}return i}async getCollectionRecommendations(t="ALL_DATA"){const l=await this.getAllAvailableCollections();switch(t){case"ALL_DATA":return l;case"CUSTOM":return l.filter(s=>!["audit_logs","roleSyncEvents","datasetAssignments"].includes(s));case"SPECIFIC":return l.filter(s=>["users","projects","sessions","inventoryItems","organizations"].includes(s));default:return l}}async needsSync(t){return!(await this.validateDatasetCollections(t)).isValid}async getCollectionStats(){return{totalAvailable:(await this.getAllAvailableCollections()).length,totalAssigned:0,coveragePercentage:0,missingCount:0,extraCount:0}}async refreshCollectionCache(){this.cachedCollections=null,this.lastCacheUpdate=0,await this.getAllAvailableCollections(),console.log("ðŸ”„ [DatasetCollectionValidator] Collection cache refreshed")}};c(n,"instance");let C=n;const x=C.getInstance();export{C as DatasetCollectionValidator,x as datasetCollectionValidator};
