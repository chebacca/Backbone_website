const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/firebase-DFSS4cDN.js","assets/index-DO6BzEGI.js","assets/mui-BEXhTKQE.js","assets/vendor-CjD1bmmO.js","assets/stripe-BgsnbYLP.js","assets/index-CBai7h7s.css","assets/index.esm-D7ujsXeY.js","assets/index.esm-DonjM_pP.js","assets/index.esm-D2YDx4vs.js"])))=>i.map(i=>d[i]);
var M=Object.defineProperty;var S=(P,e,t)=>e in P?M(P,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):P[e]=t;var f=(P,e,t)=>S(P,typeof e!="symbol"?e+"":e,t);import{_ as N}from"./index-DO6BzEGI.js";import{getDoc as b,doc as u,query as C,collection as w,where as p,getDocs as E,updateDoc as l,addDoc as z,arrayUnion as v,arrayRemove as I,limit as R,orderBy as B}from"./index.esm-DonjM_pP.js";import"./mui-BEXhTKQE.js";import"./vendor-CjD1bmmO.js";import"./stripe-BgsnbYLP.js";import"./index.esm-D7ujsXeY.js";const A=class A{constructor(){f(this,"cache",new Map);f(this,"CACHE_TTL",5*60*1e3);f(this,"db",null);f(this,"auth",null);this.initializeFirebase()}async initializeFirebase(){try{console.log("ðŸ”§ [UnifiedDataService] Initializing Firebase...");const{db:e,auth:t}=await N(async()=>{const{db:a,auth:s}=await import("./firebase-DFSS4cDN.js");return{db:a,auth:s}},__vite__mapDeps([0,1,2,3,4,5,6,7,8]));this.db=e,this.auth=t,console.log("âœ… [UnifiedDataService] Firebase initialized successfully")}catch(e){throw console.error("âŒ [UnifiedDataService] Failed to initialize Firebase:",e),e}}async waitForAuthReady(){var e;return this.auth||await this.initializeFirebase(),(e=this.auth)!=null&&e.currentUser?!0:new Promise(t=>{const a=setTimeout(()=>{t(!1)},5e3),s=this.auth.onAuthStateChanged(d=>{clearTimeout(a),s(),t(!!d)})})}async getCurrentUser(){var s,d,o,c;const e="current-user",t=this.getFromCache(e);if(t)return t;if(!await this.waitForAuthReady())return console.log("ðŸ” [UnifiedDataService] Firebase Auth not ready after waiting"),null;if(!((s=this.auth)!=null&&s.currentUser))return console.log("ðŸ” [UnifiedDataService] No Firebase Auth user found after auth ready"),null;try{const r=await b(u(this.db,"users",this.auth.currentUser.uid));if(!r.exists())return console.error("User document not found"),null;const n=r.data();let i=null;if(n.organizationId){const g=await b(u(this.db,"organizations",n.organizationId));g.exists()&&(i=g.data())}const h={id:n.organizationId||"default-org",name:(i==null?void 0:i.name)||n.organizationName||"Default Organization",tier:(i==null?void 0:i.tier)||n.tier||"BASIC",isOwner:n.userType==="ACCOUNT_OWNER"||n.role==="OWNER"},m={id:n.id||this.auth.currentUser.uid,email:n.email||"",name:n.name||n.firstName+" "+n.lastName||"Unknown User",userType:n.userType||"TEAM_MEMBER",role:n.role||"member",organization:h,license:{type:n.licenseType||n.tier||"BASIC",status:n.status||"ACTIVE",permissions:n.permissions||[],canCreateProjects:n.tier==="ENTERPRISE"||n.tier==="PROFESSIONAL",canManageTeam:n.role==="admin"||n.role==="owner"},teamMemberData:n.userType==="TEAM_MEMBER"?{managedBy:n.managedBy||"",department:n.department||"",assignedProjects:n.assignedProjects||[]}:void 0,status:n.status||"ACTIVE",createdAt:((d=n.createdAt)==null?void 0:d.toDate())||new Date,updatedAt:((o=n.updatedAt)==null?void 0:o.toDate())||new Date,lastLoginAt:(c=n.lastLoginAt)==null?void 0:c.toDate()};return this.setCache(e,m),m}catch(r){return console.error("Error fetching current user:",r),null}}async getUsersByOrganization(e){const t=`org-users-${e}`,a=this.getFromCache(t);if(a)return a;try{console.log("ðŸ” [UnifiedDataService] Fetching users for organization:",e),this.db||await this.initializeFirebase();const s=C(w(this.db,"users"),p("organizationId","==",e));console.log("ðŸ” [UnifiedDataService] Executing query for organization users...");const o=(await E(s)).docs.map(c=>{var n,i,h;const r=c.data();return{id:c.id,email:r.email||"",name:r.name||r.firstName+" "+r.lastName||"Unknown User",userType:r.userType||"TEAM_MEMBER",role:r.role||"member",organization:{id:r.organizationId||"",name:r.organizationName||"Unknown Organization",tier:r.tier||"BASIC",isOwner:r.isOwner||!1},license:{type:r.licenseType||r.tier||"BASIC",status:r.status||"ACTIVE",permissions:r.permissions||[],canCreateProjects:r.tier==="ENTERPRISE"||r.tier==="PROFESSIONAL",canManageTeam:r.role==="admin"||r.role==="owner"},teamMemberData:r.userType==="TEAM_MEMBER"?{managedBy:r.managedBy||"",department:r.department||"",assignedProjects:r.assignedProjects||[]}:void 0,status:r.status||"ACTIVE",createdAt:((n=r.createdAt)==null?void 0:n.toDate())||new Date,updatedAt:((i=r.updatedAt)==null?void 0:i.toDate())||new Date,lastLoginAt:(h=r.lastLoginAt)==null?void 0:h.toDate()}});return this.setCache(t,o),console.log("âœ… [UnifiedDataService] Successfully fetched",o.length,"users for organization:",e),o}catch(s){return console.error("âŒ [UnifiedDataService] Error fetching organization users:",s),s instanceof Error&&(console.error("Error details:",s.message),console.error("Error stack:",s.stack)),[]}}async updateUser(e,t){try{const a={...t,updatedAt:new Date};await l(u(this.db,"users",e),a),this.clearCacheByPattern("current-user"),this.clearCacheByPattern("org-users-"),this.clearCacheByPattern("org-context-")}catch(a){throw console.error("Error updating user:",a),a}}async getProjectsForUser(){const e=await this.getCurrentUser();if(!e)return[];const t=`user-projects-${e.id}`,a=this.getFromCache(t);if(a)return a;try{const s=C(w(this.db,"projects"),p("organizationId","==",e.organization.id)),o=(await E(s)).docs.map(c=>{var n,i,h;const r=c.data();return{...r,id:c.id,createdAt:((n=r.createdAt)==null?void 0:n.toDate())||new Date,updatedAt:((i=r.updatedAt)==null?void 0:i.toDate())||new Date,lastAccessedAt:((h=r.lastAccessedAt)==null?void 0:h.toDate())||new Date}});return this.setCache(t,o),o}catch(s){return console.error("Error fetching user projects:",s),[]}}async createProject(e){try{if(!await this.getCurrentUser())throw new Error("No authenticated user");const a={...e,createdAt:new Date,updatedAt:new Date,lastAccessedAt:new Date},s=await z(w(this.db,"projects"),a);return this.clearCacheByPattern("user-projects-"),this.clearCacheByPattern("org-projects-"),this.clearCacheByPattern("org-context-"),s.id}catch(t){throw console.error("Error creating project:",t),t}}async updateProject(e,t){try{const a={...t,updatedAt:new Date};await l(u(this.db,"projects",e),a),this.clearCacheByPattern("user-projects-"),this.clearCacheByPattern("project-")}catch(a){throw console.error("Error updating project:",a),a}}async addTeamMemberToProject(e,t,a){try{const s=await b(u(this.db,"users",t));if(!s.exists())throw new Error("User not found");const d=s.data(),o=await this.getCurrentUser(),c={userId:d.id,email:d.email,name:d.name,role:a,assignedAt:new Date,assignedBy:(o==null?void 0:o.email)||"system"};await l(u(this.db,"projects",e),{teamAssignments:v(c),updatedAt:new Date}),await l(u(this.db,"users",t),{"teamMemberData.assignedProjects":v(e),updatedAt:new Date}),this.clearCacheByPattern("user-projects-"),this.clearCacheByPattern("project-")}catch(s){throw console.error("Error adding team member to project:",s),s}}async removeTeamMemberFromProject(e,t){try{const a=await b(u(this.db,"projects",e));if(!a.exists())throw new Error("Project not found");const d=a.data().teamAssignments.find(o=>o.userId===t);d&&(await l(u(this.db,"projects",e),{teamAssignments:I(d),updatedAt:new Date}),await l(u(this.db,"users",t),{"teamMemberData.assignedProjects":I(e),updatedAt:new Date}),this.clearCacheByPattern("user-projects-"),this.clearCacheByPattern("project-"))}catch(a){throw console.error("Error removing team member from project:",a),a}}async getOrganizationContext(){var s,d,o,c,r,n;(!this.auth||!this.db)&&await this.initializeFirebase();const e=await this.getCurrentUser();if(!e)throw new Error("No authenticated user");const t=`org-context-${e.organization.id}`,a=this.getFromCache(t);if(a)return a;try{const i=await b(u(this.db,"organizations",e.organization.id));if(!i.exists())throw new Error(`Organization ${e.organization.id} not found`);const h=i.data(),m={...h,id:e.organization.id,createdAt:((s=h.createdAt)==null?void 0:s.toDate())||new Date,updatedAt:((d=h.updatedAt)==null?void 0:d.toDate())||new Date},g=C(w(this.db,"subscriptions"),p("organizationId","==",e.organization.id),p("status","==","ACTIVE"),R(1)),D=await E(g);let U=null;if(!D.empty){const y=D.docs[0].data();U={...y,id:D.docs[0].id,createdAt:((o=y.createdAt)==null?void 0:o.toDate())||new Date,updatedAt:((c=y.updatedAt)==null?void 0:c.toDate())||new Date,currentPeriodStart:((r=y.currentPeriodStart)==null?void 0:r.toDate())||new Date,currentPeriodEnd:((n=y.currentPeriodEnd)==null?void 0:n.toDate())||new Date}}let j=[];try{j=await this.getUsersByOrganization(e.organization.id)}catch(y){throw console.error("Failed to get organization members:",y),y}const F={organization:m,subscription:U,members:j};return this.setCache(t,F,10*60*1e3),F}catch(i){throw console.error("Error fetching organization context:",i),i}}async getLicensesForOrganization(){(!this.auth||!this.db)&&await this.initializeFirebase();const e=await this.getCurrentUser();if(!e)return console.log("ðŸ” [UnifiedDataService] No user found for license query"),[];const t=`org-licenses-${e.organization.id}`,a=this.getFromCache(t);if(a)return a;try{const s=C(w(this.db,"licenses"),p("organizationId","==",e.organization.id),B("createdAt","desc")),o=(await E(s)).docs.map(c=>{var n,i,h,m,g,D;const r=c.data();return{id:c.id,key:r.key||"",name:r.name||`License ${c.id}`,tier:r.tier||"BASIC",status:r.status||"PENDING",organization:{id:r.organizationId||"",name:r.organizationName||"Unknown Organization",tier:r.tier||"BASIC"},assignedTo:r.userId?{userId:r.userId,name:r.userName||r.userEmail||"Unknown User",email:r.userEmail||"",assignedAt:((n=r.activatedAt)==null?void 0:n.toDate())||new Date}:void 0,usage:{apiCalls:r.usageCount||0,dataTransfer:0,deviceCount:1,maxDevices:r.tier==="ENTERPRISE"?10:r.tier==="PROFESSIONAL"?5:2},activatedAt:(i=r.activatedAt)==null?void 0:i.toDate(),expiresAt:((h=r.expiresAt)==null?void 0:h.toDate())||new Date,lastUsed:(m=r.lastUsed)==null?void 0:m.toDate(),createdAt:((g=r.createdAt)==null?void 0:g.toDate())||new Date,updatedAt:((D=r.updatedAt)==null?void 0:D.toDate())||new Date}});return this.setCache(t,o),o}catch(s){return console.error("Error fetching organization licenses:",s),[]}}async createLicense(e){try{if(!await this.getCurrentUser())throw new Error("No authenticated user");const a={...e,createdAt:new Date,updatedAt:new Date},s=await z(w(this.db,"licenses"),a);return this.clearCacheByPattern("org-licenses-"),s.id}catch(t){throw console.error("Error creating license:",t),t}}async updateLicense(e,t){try{const a={...t,updatedAt:new Date};await l(u(this.db,"licenses",e),a),this.clearCacheByPattern("org-licenses-")}catch(a){throw console.error("Error updating license:",a),a}}async assignLicense(e,t){try{const a=await b(u(this.db,"users",t));if(!a.exists())throw new Error("User not found");const s=a.data();await l(u(this.db,"licenses",e),{assignedTo:{userId:t,name:s.name||s.email,email:s.email,assignedAt:new Date},status:"ACTIVE",updatedAt:new Date}),this.clearCacheByPattern("org-licenses-")}catch(a){throw console.error("Error assigning license:",a),a}}async unassignLicense(e){try{await l(u(this.db,"licenses",e),{assignedTo:null,updatedAt:new Date}),this.clearCacheByPattern("org-licenses-")}catch(t){throw console.error("Error unassigning license:",t),t}}async getTeamMembersForOrganization(){const e=await this.getCurrentUser();if(!e)return[];const t=`org-team-members-${e.organization.id}`,a=this.getFromCache(t);if(a)return a;try{const s=C(w(this.db,"teamMembers"),p("organizationId","==",e.organization.id),B("createdAt","desc")),o=(await E(s)).docs.map(c=>{var n,i,h,m,g;const r=c.data();return{...r,id:c.id,createdAt:((n=r.createdAt)==null?void 0:n.toDate())||new Date,updatedAt:((i=r.updatedAt)==null?void 0:i.toDate())||new Date,joinedAt:((h=r.joinedAt)==null?void 0:h.toDate())||new Date,lastActive:(m=r.lastActive)==null?void 0:m.toDate(),licenseAssignment:r.licenseAssignment?{...r.licenseAssignment,assignedAt:((g=r.licenseAssignment.assignedAt)==null?void 0:g.toDate())||new Date}:void 0}});return this.setCache(t,o),o}catch(s){return console.error("Error fetching team members:",s),[]}}async inviteTeamMember(e){try{const t=await this.getCurrentUser();if(!t)throw new Error("No authenticated user");const a={...e,status:"pending",invitedBy:t.email,joinedAt:new Date,createdAt:new Date,updatedAt:new Date},s=await z(w(this.db,"team_members"),a);return this.clearCacheByPattern("org-team-members-"),this.clearCacheByPattern("org-users-"),s.id}catch(t){throw console.error("Error inviting team member:",t),t}}async updateTeamMember(e,t){try{const a={...t,updatedAt:new Date};await l(u(this.db,"team_members",e),a),this.clearCacheByPattern("org-team-members-"),this.clearCacheByPattern("org-users-")}catch(a){throw console.error("Error updating team member:",a),a}}async removeTeamMember(e){try{await l(u(this.db,"team_members",e),{status:"removed",updatedAt:new Date}),this.clearCacheByPattern("org-team-members-"),this.clearCacheByPattern("org-users-")}catch(t){throw console.error("Error removing team member:",t),t}}async assignLicenseToTeamMember(e,t,a,s){try{await l(u(this.db,"team_members",e),{licenseAssignment:{licenseId:t,licenseKey:a,licenseType:s,assignedAt:new Date},updatedAt:new Date}),this.clearCacheByPattern("org-team-members-"),this.clearCacheByPattern("org-licenses-")}catch(d){throw console.error("Error assigning license to team member:",d),d}}async getDatasetsForUser(){const e=await this.getCurrentUser();if(!e)return[];const t=`user-datasets-${e.id}`,a=this.getFromCache(t);if(a)return a;try{const s=C(w(this.db,"datasets"),p("owner.organizationId","==",e.organization.id),p("status","==","ACTIVE"),B("updatedAt","desc")),o=(await E(s)).docs.map(c=>{var n,i;const r=c.data();return{...r,id:c.id,createdAt:((n=r.createdAt)==null?void 0:n.toDate())||new Date,updatedAt:((i=r.updatedAt)==null?void 0:i.toDate())||new Date}});return this.setCache(t,o),o}catch(s){return console.error("Error fetching user datasets:",s),[]}}getFromCache(e){const t=this.cache.get(e);return t?Date.now()>t.timestamp+t.ttl?(this.cache.delete(e),null):t.data:null}setCache(e,t,a=this.CACHE_TTL){this.cache.set(e,{data:t,timestamp:Date.now(),ttl:a})}clearCacheByPattern(e){for(const t of this.cache.keys())t.includes(e)&&this.cache.delete(t)}clearAllCache(){this.cache.clear()}clearUserCache(e){e?(this.clearCacheByPattern("current-user"),this.clearCacheByPattern(`org-users-${e}`),this.clearCacheByPattern("org-context"),this.clearCacheByPattern("org-licenses")):this.clearAllCache()}static getInstance(){return A.instance||(A.instance=new A),A.instance}};f(A,"instance");let T=A;const K=T.getInstance();export{K as default,K as unifiedDataService};
